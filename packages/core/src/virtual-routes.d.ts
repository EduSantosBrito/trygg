/**
 * Type declarations for virtual:effect-ui-routes module
 * Generated by the effect-ui vite plugin when routes option is enabled.
 *
 * ## Type-Safe Routing
 *
 * The plugin generates a RouteMap interface based on your route files:
 *
 * ```tsx
 * // Link autocompletes valid paths
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 *
 * // TypeScript catches errors
 * <Link to="/users/:id">User</Link>  // Error: params required
 * <Link to="/invalid">X</Link>        // Error: path not in RouteMap
 * ```
 */
declare module "virtual:effect-ui-routes" {
  import type { Effect } from "effect";
  import type { ComponentType, Element } from "effect-ui";

  // ==========================================
  // Type Utilities for Route Param Extraction
  // ==========================================

  /**
   * Extract route params from a path pattern.
   *
   * @example
   * ```ts
   * type P1 = ExtractRouteParams<"/users/:id">
   * // Result: { id: string }
   *
   * type P2 = ExtractRouteParams<"/posts/:postId/comments/:commentId">
   * // Result: { postId: string; commentId: string }
   *
   * type P3 = ExtractRouteParams<"/about">
   * // Result: {}
   * ```
   */
  export type ExtractRouteParams<T extends string> =
    // Handle :param/rest pattern
    T extends `${infer _Start}:${infer Param}/${infer Rest}`
      ? { readonly [K in Param]: string } & ExtractRouteParams<`/${Rest}`>
      : // Handle trailing :param pattern
        T extends `${infer _Start}:${infer Param}`
        ? { readonly [K in Param]: string }
        : // No params found
          {};

  /**
   * Check if params object is empty (no dynamic segments)
   */
  export type IsEmptyParams<T> = keyof T extends never ? true : false;

  // ==========================================
  // Route Definition Types
  // ==========================================

  interface RouteDefinition {
    readonly path: string;
    readonly component: () => Promise<{
      default:
        | ComponentType<Record<string, never>, unknown>
        | Effect.Effect<Element, unknown, unknown>;
    }>;
    readonly layout?: () => Promise<{
      default:
        | ComponentType<Record<string, never>, unknown>
        | Effect.Effect<Element, unknown, unknown>;
    }>;
    readonly guard?: () => Promise<{ guard?: Effect.Effect<void, unknown, never> }>;
  }

  // ==========================================
  // Generated Route Map (Placeholder)
  // ==========================================

  /**
   * Route map generated by the vite plugin.
   * Maps path patterns to their param types.
   *
   * This interface is augmented by the generated routes.
   * If you're seeing type errors, make sure:
   * 1. You have `routes` option configured in vite plugin
   * 2. The dev server is running (types are generated at build time)
   *
   * @example Generated interface:
   * ```ts
   * interface RouteMap {
   *   "/": {}
   *   "/users": {}
   *   "/users/:id": { id: string }
   * }
   * ```
   */
  export interface RouteMap {
    // This will be augmented by generated types
    // Fallback allows any string when types aren't generated
    [path: string]: Record<string, string>;
  }

  /**
   * All valid route paths from the RouteMap
   */
  export type RoutePath = keyof RouteMap & string;

  /**
   * Get params type for a specific route path
   */
  export type RouteParams<P extends RoutePath> = RouteMap[P];

  // ==========================================
  // Exports
  // ==========================================

  export const routes: ReadonlyArray<RouteDefinition>;
  export default routes;
}
