/**
 * @since 1.0.0
 * Router types for trygg
 *
 * ## Type-Safe Routing
 *
 * This module provides type utilities for type-safe navigation:
 *
 * ```tsx
 * // Path autocomplete and param validation
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 *
 * // TypeScript error: missing required param
 * <Link to="/users/:id">User</Link>
 * ```
 */
import { Data, Effect, type Cause, type Ref } from "effect";
import { Component } from "../primitives/component.js";
import type { Element } from "../primitives/element.js";
import type { Signal } from "../primitives/signal.js";

// ==========================================
// Errors
// ==========================================

/**
 * Error representing a failed navigation operation.
 * Wraps underlying platform errors (HistoryError, LocationError, etc.)
 * so consumers can handle navigation failures explicitly.
 *
 * @since 1.0.0
 */
export class NavigationError extends Data.TaggedError("NavigationError")<{
  readonly operation: string;
  readonly cause: unknown;
}> {}

// ==========================================
// Route Map (augmented by vite plugin)
// ==========================================

/**
 * Route map interface - augmented by vite plugin with actual routes.
 *
 * When using file-based routing, the vite plugin generates a routes.d.ts
 * that augments this interface with your actual route paths and params.
 *
 * @example
 * ```ts
 * // Generated by vite plugin in routes.d.ts:
 * declare module "trygg/router" {
 *   interface RouteMap {
 *     "/": {}
 *     "/users": {}
 *     "/users/:id": { readonly id: string }
 *   }
 * }
 * ```
 *
 * @since 1.0.0
 */
export interface RouteMap {
  // Augmented by vite plugin
}

/**
 * Route component type - Component.gen result or Effect<Element>.
 * @since 1.0.0
 */
export type RouteComponent =
  | Component.Type<never, unknown, unknown>
  | Effect.Effect<Element, unknown, unknown>;

/**
 * Get all route paths from RouteMap.
 * Uses `(string & Record<never, never>)` pattern for autocomplete with string fallback.
 * @since 1.0.0
 */
export type RoutePath = keyof RouteMap | (string & Record<never, never>);

// ==========================================
// Type-Safe Routing Utilities
// ==========================================

/**
 * Extract route params from a path pattern.
 * Uses template literal types to parse :param segments.
 *
 * @example
 * ```ts
 * type P1 = ExtractRouteParams<"/users/:id">
 * // { readonly id: string }
 *
 * type P2 = ExtractRouteParams<"/posts/:postId/comments/:commentId">
 * // { readonly postId: string; readonly commentId: string }
 *
 * type P3 = ExtractRouteParams<"/about">
 * // {}
 * ```
 *
 * @since 1.0.0
 */
export type ExtractRouteParams<T extends string> =
  // Handle :param/rest pattern
  T extends `${infer _Start}:${infer Param}/${infer Rest}`
    ? { readonly [K in Param]: string } & ExtractRouteParams<`/${Rest}`>
    : // Handle trailing :param pattern
      T extends `${infer _Start}:${infer Param}`
      ? { readonly [K in Param]: string }
      : // No params found
        {};

/**
 * Simplify intersection types for better display
 * @internal
 */
type Simplify<T> = { [K in keyof T]: T[K] } & {};

/**
 * Check if a type has any keys
 * @internal
 */
type HasKeys<T> = keyof T extends never ? false : true;

/**
 * Get route params type for a path.
 * Uses RouteMap if available (from vite plugin), otherwise extracts from path pattern.
 *
 * @example
 * ```ts
 * // With RouteMap (vite plugin):
 * type P1 = RouteParamsFor<"/users/:id">  // RouteMap["/users/:id"]
 *
 * // Without RouteMap (fallback):
 * type P2 = RouteParamsFor<"/posts/:postId">  // { readonly postId: string }
 * ```
 *
 * @since 1.0.0
 */
export type RouteParamsFor<Path extends string> = Path extends keyof RouteMap
  ? Simplify<RouteMap[Path]>
  : Simplify<ExtractRouteParams<Path>>;

/**
 * Props for type-safe Link component.
 *
 * When the path contains dynamic segments (`:param`), the `params` prop is required.
 * When the path is static, `params` is optional/unnecessary.
 *
 * @example
 * ```tsx
 * // Static path - no params needed
 * <Link to="/">Home</Link>
 *
 * // Dynamic path - params required
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 *
 * // TypeScript enforces correct param names
 * <Link to="/users/:id" params={{ wrong: "x" }}>Error!</Link>
 * ```
 *
 * @since 1.0.0
 */
export type TypeSafeLinkProps<Path extends string> =
  HasKeys<RouteParamsFor<Path>> extends true
    ? {
        readonly to: Path;
        readonly params: RouteParamsFor<Path>;
        readonly query?: Record<string, string>;
        readonly replace?: boolean;
        readonly children?: unknown;
        readonly className?: string;
      }
    : {
        readonly to: Path;
        readonly params?: never;
        readonly query?: Record<string, string>;
        readonly replace?: boolean;
        readonly children?: unknown;
        readonly className?: string;
      };

/**
 * Build a URL path by substituting params into a pattern.
 *
 * @example
 * ```ts
 * buildPathWithParams("/users/:id", { id: "123" })
 * // "/users/123"
 *
 * buildPathWithParams("/posts/:postId/comments/:commentId", { postId: "1", commentId: "2" })
 * // "/posts/1/comments/2"
 * ```
 *
 * @since 1.0.0
 */
export const buildPathWithParams = <Path extends string>(
  path: Path,
  params: RouteParamsFor<Path>,
): Effect.Effect<string> =>
  Effect.sync(() => {
    let result: string = path;
    for (const key of Object.keys(params)) {
      const value = (params as Record<string, string | number>)[key];
      if (value !== undefined) {
        result = result.replace(`:${key}`, String(value));
      }
    }
    return result;
  });

/**
 * Interpolate params into a path pattern using NavigateOptions.params.
 * Handles both string and number values (numbers are converted via String()).
 *
 * @example
 * ```ts
 * interpolateParams("/users/:id", { id: 123 })
 * // "/users/123"
 * ```
 *
 * @internal
 */
export const interpolateParams = (
  path: string,
  params: Record<string, string | number>,
): Effect.Effect<string> =>
  Effect.sync(() => {
    let result = path;
    for (const key of Object.keys(params)) {
      const value = params[key];
      if (value !== undefined) {
        result = result.replace(`:${key}`, String(value));
      }
    }
    return result;
  });

// ==========================================
// Basic Types
// ==========================================

/**
 * Route parameters extracted from path
 * @since 1.0.0
 */
export type RouteParams = Record<string, string>;

/**
 * Current route state
 * @since 1.0.0
 */
export interface Route {
  /** Current path (e.g., "/users/123") */
  readonly path: string;
  /** Extracted route parameters */
  readonly params: RouteParams;
  /** Query string parameters */
  readonly query: URLSearchParams;
}

/**
 * Navigation options
 * @since 1.0.0
 */
export interface NavigateOptions {
  /** Replace current history entry instead of pushing */
  readonly replace?: boolean;
  /** Query parameters to set */
  readonly query?: Record<string, string>;
  /** Path params to interpolate into path pattern (e.g., { id: 123 } for "/users/:id") */
  readonly params?: Record<string, string | number>;
}

/**
 * Options for Router.isActive check.
 * @since 1.0.0
 */
export interface IsActiveOptions {
  /** Path params to interpolate before comparison (e.g., { id: 123 } for "/users/:id") */
  readonly params?: Record<string, string | number>;
  /** If true, path must match exactly. If false (default), prefix matching is used. */
  readonly exact?: boolean;
}

/**
 * Route error info - available to .error() boundary components via RouteError FiberRef
 * @since 1.0.0
 */
export interface RouteErrorInfo {
  /** The cause of the error - use Cause.squash for display, Cause.match for pattern matching */
  readonly cause: Cause.Cause<unknown>;
  /** The route path that errored */
  readonly path: string;
  /** Reset effect to retry rendering the route - use in onClick handler */
  readonly reset: Effect.Effect<void, never, never>;
}

/**
 * Navigation context set by the router before each route signal update.
 * Read by the outlet to determine scroll behavior after route matching.
 * @since 1.0.0
 * @internal
 */
export interface NavigationContext {
  readonly isPopstate: boolean;
  readonly hash: string;
  readonly scrollKey: string;
}

/**
 * Router service interface
 * @since 1.0.0
 */
export interface RouterService {
  /** Signal containing current route state */
  readonly current: Signal<Route>;

  /** Navigate to a path. Fails with NavigationError if history/location operations fail. */
  readonly navigate: (
    path: string,
    options?: NavigateOptions,
  ) => Effect.Effect<void, NavigationError>;

  /** Go back in history */
  readonly back: () => Effect.Effect<void>;

  /** Go forward in history */
  readonly forward: () => Effect.Effect<void>;

  /** Get current route params (type-safe by path pattern) */
  readonly params: <Path extends RoutePath>(path: Path) => Effect.Effect<RouteParamsFor<Path>>;

  /** Get query params signal */
  readonly query: Signal<URLSearchParams>;

  /** Check if a path matches current route. Supports param interpolation. */
  readonly isActive: (path: string, options?: IsActiveOptions) => Effect.Effect<boolean>;

  /**
   * Prefetch route modules for a path.
   * Loads all modules (component, layouts) for the matched route into cache.
   * Best-effort: failures are silently ignored.
   * @since 1.0.0
   */
  readonly prefetch: (path: string) => Effect.Effect<void>;

  /**
   * Navigation context Ref â€” set before each route signal update.
   * Read by the outlet to determine scroll behavior.
   * @internal
   */
  readonly _navigationContext: Ref.Ref<NavigationContext>;

  /**
   * Apply scroll behavior using captured platform services.
   * Called by the outlet after matching a route and determining the strategy.
   * @internal
   */
  readonly _applyScroll: (options: { readonly strategyKey: string }) => Effect.Effect<void>;

  /**
   * Save current scroll position (best-effort, errors ignored).
   * Called by the outlet before route transitions if needed.
   * @internal
   */
  readonly _saveScroll: Effect.Effect<void>;
}
