/**
 * @since 1.0.0
 * Router types for effect-ui
 * 
 * ## Type-Safe Routing
 * 
 * This module provides type utilities for type-safe navigation:
 * 
 * ```tsx
 * // Path autocomplete and param validation
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 * 
 * // TypeScript error: missing required param
 * <Link to="/users/:id">User</Link>
 * ```
 */
import { Data } from "effect"
import type { Cause, Effect } from "effect"
import type { ComponentType } from "../component.js"
import type { Element } from "../element.js"
import type { Signal } from "../signal.js"

// ==========================================
// Route Map (augmented by vite plugin)
// ==========================================

/**
 * Route map interface - augmented by vite plugin with actual routes.
 * 
 * When using file-based routing, the vite plugin generates a routes.d.ts
 * that augments this interface with your actual route paths and params.
 * 
 * @example
 * ```ts
 * // Generated by vite plugin in routes.d.ts:
 * declare module "effect-ui/router" {
 *   interface RouteMap {
 *     "/": {}
 *     "/users": {}
 *     "/users/:id": { readonly id: string }
 *   }
 * }
 * ```
 * 
 * @since 1.0.0
 */
export interface RouteMap {
  // Augmented by vite plugin
}

/**
 * Route component type - Component.gen result or Effect<Element>.
 * @since 1.0.0
 */
export type RouteComponent =
  | ComponentType<Record<string, never>, unknown>
  | Effect.Effect<Element, unknown, unknown>

/**
 * Get all route paths from RouteMap.
 * Uses `(string & Record<never, never>)` pattern for autocomplete with string fallback.
 * @since 1.0.0
 */
export type RoutePath = keyof RouteMap | (string & Record<never, never>)

// ==========================================
// Type-Safe Routing Utilities  
// ==========================================

/**
 * Extract route params from a path pattern.
 * Uses template literal types to parse :param segments.
 * 
 * @example
 * ```ts
 * type P1 = ExtractRouteParams<"/users/:id">
 * // { readonly id: string }
 * 
 * type P2 = ExtractRouteParams<"/posts/:postId/comments/:commentId">
 * // { readonly postId: string; readonly commentId: string }
 * 
 * type P3 = ExtractRouteParams<"/about">
 * // {}
 * ```
 * 
 * @since 1.0.0
 */
export type ExtractRouteParams<T extends string> =
  // Handle :param/rest pattern
  T extends `${infer _Start}:${infer Param}/${infer Rest}`
    ? { readonly [K in Param]: string } & ExtractRouteParams<`/${Rest}`>
    // Handle trailing :param pattern
    : T extends `${infer _Start}:${infer Param}`
    ? { readonly [K in Param]: string }
    // No params found
    : {}

/**
 * Simplify intersection types for better display
 * @internal
 */
type Simplify<T> = { [K in keyof T]: T[K] } & {}

/**
 * Check if a type has any keys
 * @internal
 */
type HasKeys<T> = keyof T extends never ? false : true

/**
 * Get route params type for a path.
 * Uses RouteMap if available (from vite plugin), otherwise extracts from path pattern.
 * 
 * @example
 * ```ts
 * // With RouteMap (vite plugin):
 * type P1 = RouteParamsFor<"/users/:id">  // RouteMap["/users/:id"]
 * 
 * // Without RouteMap (fallback):
 * type P2 = RouteParamsFor<"/posts/:postId">  // { readonly postId: string }
 * ```
 * 
 * @since 1.0.0
 */
export type RouteParamsFor<Path extends string> = 
  Path extends keyof RouteMap 
    ? Simplify<RouteMap[Path]>
    : Simplify<ExtractRouteParams<Path>>

/**
 * Props for type-safe Link component.
 * 
 * When the path contains dynamic segments (`:param`), the `params` prop is required.
 * When the path is static, `params` is optional/unnecessary.
 * 
 * @example
 * ```tsx
 * // Static path - no params needed
 * <Link to="/">Home</Link>
 * 
 * // Dynamic path - params required
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 * 
 * // TypeScript enforces correct param names
 * <Link to="/users/:id" params={{ wrong: "x" }}>Error!</Link>
 * ```
 * 
 * @since 1.0.0
 */
export type TypeSafeLinkProps<Path extends string> = 
  HasKeys<RouteParamsFor<Path>> extends true
    ? {
        readonly to: Path
        readonly params: RouteParamsFor<Path>
        readonly query?: Record<string, string>
        readonly replace?: boolean
        readonly children?: unknown
        readonly className?: string
      }
    : {
        readonly to: Path
        readonly params?: never
        readonly query?: Record<string, string>
        readonly replace?: boolean
        readonly children?: unknown
        readonly className?: string
      }

/**
 * Build a URL path by substituting params into a pattern.
 * 
 * @example
 * ```ts
 * buildPathWithParams("/users/:id", { id: "123" })
 * // "/users/123"
 * 
 * buildPathWithParams("/posts/:postId/comments/:commentId", { postId: "1", commentId: "2" })
 * // "/posts/1/comments/2"
 * ```
 * 
 * @since 1.0.0
 */
export const buildPathWithParams = <Path extends string>(
  path: Path,
  params: RouteParamsFor<Path>
): string => {
  let result: string = path
  for (const key of Object.keys(params)) {
    const value = (params as Record<string, string>)[key]
    if (value !== undefined) {
      result = result.replace(`:${key}`, value)
    }
  }
  return result
}

// ==========================================
// Basic Types
// ==========================================

/**
 * Route parameters extracted from path
 * @since 1.0.0
 */
export type RouteParams = Record<string, string>

/**
 * Current route state
 * @since 1.0.0
 */
export interface Route {
  /** Current path (e.g., "/users/123") */
  readonly path: string
  /** Extracted route parameters */
  readonly params: RouteParams
  /** Query string parameters */
  readonly query: URLSearchParams
}

/**
 * Navigation options
 * @since 1.0.0
 */
export interface NavigateOptions {
  /** Replace current history entry instead of pushing */
  readonly replace?: boolean
  /** Query parameters to set */
  readonly query?: Record<string, string>
}

/**
 * Route definition - maps path pattern to component loader
 * @since 1.0.0
 */
export interface RouteDefinition {
  /** Path pattern (e.g., "/users/:id") */
  readonly path: string
  /** Component loader - returns Component.gen result or Effect<Element> */
  readonly component: () => Promise<{ default: RouteComponent }>
  /** Optional guard effect */
  readonly guard?: () => Promise<{ guard?: Effect.Effect<void, unknown, never> }>
  /** Optional loading component - displayed while route is loading */
  readonly loadingComponent?: () => Promise<{ default: RouteComponent }>
  /** Optional error component - displayed when route errors, receives error via RouteError service */
  readonly errorComponent?: () => Promise<{ default: RouteComponent }>
  /** Child routes (for nested layouts) */
  readonly children?: ReadonlyArray<RouteDefinition>
  /** Layout component for children */
  readonly layout?: () => Promise<{ default: RouteComponent }>
}

/**
 * Route match result
 * @since 1.0.0
 */
export interface RouteMatch {
  /** The matched route definition */
  readonly route: RouteDefinition
  /** Extracted parameters */
  readonly params: RouteParams
  /** Parent matches (for nested routes) */
  readonly parents: ReadonlyArray<RouteMatch>
}

/**
 * Router redirect result - returned from guards to redirect
 * @since 1.0.0
 */
export interface RouterRedirect {
  readonly _tag: "RouterRedirect"
  readonly path: string
  readonly options?: NavigateOptions
}

/**
 * Create a redirect result for use in guards.
 * 
 * Use this in guard effects to redirect to another route.
 * The guard should yield* this effect to trigger the redirect.
 * 
 * @example
 * ```tsx
 * // routes/dashboard/index.tsx
 * import { Effect, Option } from "effect"
 * import { Router } from "effect-ui/router"
 * 
 * export const guard = Effect.gen(function* () {
 *   const user = yield* AuthService.getCurrentUser
 *   if (Option.isNone(user)) {
 *     yield* Router.redirect("/login")
 *   }
 * })
 * 
 * export default Effect.gen(function* () {
 *   return <div>Protected Dashboard</div>
 * })
 * ```
 * 
 * @since 1.0.0
 */
export const redirect = (path: string, options?: NavigateOptions): RouterRedirect => {
  const result: RouterRedirect = { _tag: "RouterRedirect", path }
  if (options !== undefined) {
    return { ...result, options }
  }
  return result
}

/**
 * Check if a value is a RouterRedirect
 * @since 1.0.0
 */
export const isRedirect = (value: unknown): value is RouterRedirect =>
  typeof value === "object" &&
  value !== null &&
  "_tag" in value &&
  (value as { _tag: unknown })._tag === "RouterRedirect"

/**
 * Guard blocked error - thrown when a guard blocks navigation
 * @since 1.0.0
 */
export class GuardBlocked {
  readonly _tag = "GuardBlocked"
  constructor(readonly redirect: RouterRedirect) {}
}

/**
 * Route render error - wraps errors (including defects) from route component rendering.
 * Used by error boundaries to normalize both typed failures and thrown exceptions.
 * @since 1.0.0
 */
export class RouteRenderError {
  readonly _tag = "RouteRenderError"
  constructor(
    /** The original error or defect */
    readonly cause: unknown,
    /** The route path where the error occurred */
    readonly path: string
  ) {}
}

/**
 * Error thrown when a route module load times out.
 * Used by the module loader for timeout/retry handling.
 * @since 1.0.0
 */
export class RouteLoadTimeoutError extends Data.TaggedError("RouteLoadTimeoutError")<{
  readonly path: string
  readonly kind: "component" | "layout" | "guard" | "loading" | "error" | "not_found"
  readonly timeout_ms: number
  readonly attempt: number
  readonly is_prefetch: boolean
}> {}

/**
 * Routes manifest - generated by vite plugin
 * @since 1.0.0
 */
export type RoutesManifest = ReadonlyArray<RouteDefinition>

/**
 * Route error info - available to _error.tsx components via RouteError FiberRef
 * @since 1.0.0
 */
export interface RouteErrorInfo {
  /** The cause of the error - use Cause.squash for display, Cause.match for pattern matching */
  readonly cause: Cause.Cause<unknown>
  /** The route path that errored */
  readonly path: string
  /** Reset effect to retry rendering the route - use in onClick handler */
  readonly reset: Effect.Effect<void, never, never>
}

/**
 * Router service interface
 * @since 1.0.0
 */
export interface RouterService {
  /** Signal containing current route state */
  readonly current: Signal<Route>
  
  /** Navigate to a path */
  readonly navigate: (path: string, options?: NavigateOptions) => Effect.Effect<void>
  
  /** Go back in history */
  readonly back: () => Effect.Effect<void>
  
  /** Go forward in history */
  readonly forward: () => Effect.Effect<void>
  
  /** Get current route params (type-safe by path pattern) */
  readonly params: <Path extends RoutePath>(path: Path) => Effect.Effect<RouteParamsFor<Path>>
  
  /** Get query params signal */
  readonly query: Signal<URLSearchParams>
  
  /** Check if a path matches current route */
  readonly isActive: (path: string, exact?: boolean) => Effect.Effect<boolean>
  
  /**
   * Prefetch route modules for a path.
   * Loads all modules (component, layouts) for the matched route into cache.
   * Best-effort: failures are silently ignored.
   * @since 1.0.0
   */
  readonly prefetch: (path: string) => Effect.Effect<void>
}
