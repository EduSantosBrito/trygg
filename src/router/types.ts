/**
 * @since 1.0.0
 * Router types for effect-ui
 * 
 * ## Type-Safe Routing
 * 
 * This module provides type utilities for type-safe navigation:
 * 
 * ```tsx
 * // Path autocomplete and param validation
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 * 
 * // TypeScript error: missing required param
 * <Link to="/users/:id">User</Link>
 * ```
 */
import type { Effect } from "effect"
import type { Element } from "../Element.js"
import type { Signal } from "../Signal.js"

// ==========================================
// Route Map (augmented by vite plugin)
// ==========================================

/**
 * Route map interface - augmented by vite plugin with actual routes.
 * 
 * When using file-based routing, the vite plugin generates a routes.d.ts
 * that augments this interface with your actual route paths and params.
 * 
 * @example
 * ```ts
 * // Generated by vite plugin in routes.d.ts:
 * declare module "effect-ui/router" {
 *   interface RouteMap {
 *     "/": {}
 *     "/users": {}
 *     "/users/:id": { readonly id: string }
 *   }
 * }
 * ```
 * 
 * @since 1.0.0
 */
export interface RouteMap {
  // Augmented by vite plugin
}

/**
 * Get all route paths from RouteMap
 * Falls back to string if RouteMap is empty (no routes configured)
 * @since 1.0.0
 */
export type RoutePath = keyof RouteMap extends never ? string : (keyof RouteMap | (string & {}))

// ==========================================
// Type-Safe Routing Utilities  
// ==========================================

/**
 * Extract route params from a path pattern.
 * Uses template literal types to parse :param segments.
 * 
 * @example
 * ```ts
 * type P1 = ExtractRouteParams<"/users/:id">
 * // { readonly id: string }
 * 
 * type P2 = ExtractRouteParams<"/posts/:postId/comments/:commentId">
 * // { readonly postId: string; readonly commentId: string }
 * 
 * type P3 = ExtractRouteParams<"/about">
 * // {}
 * ```
 * 
 * @since 1.0.0
 */
export type ExtractRouteParams<T extends string> =
  // Handle :param/rest pattern
  T extends `${infer _Start}:${infer Param}/${infer Rest}`
    ? { readonly [K in Param]: string } & ExtractRouteParams<`/${Rest}`>
    // Handle trailing :param pattern
    : T extends `${infer _Start}:${infer Param}`
    ? { readonly [K in Param]: string }
    // No params found
    : {}

/**
 * Simplify intersection types for better display
 * @internal
 */
type Simplify<T> = { [K in keyof T]: T[K] } & {}

/**
 * Check if a type has any keys
 * @internal
 */
type HasKeys<T> = keyof T extends never ? false : true

/**
 * Props for type-safe Link component.
 * 
 * When the path contains dynamic segments (`:param`), the `params` prop is required.
 * When the path is static, `params` is optional/unnecessary.
 * 
 * @example
 * ```tsx
 * // Static path - no params needed
 * <Link to="/">Home</Link>
 * 
 * // Dynamic path - params required
 * <Link to="/users/:id" params={{ id: "123" }}>User</Link>
 * 
 * // TypeScript enforces correct param names
 * <Link to="/users/:id" params={{ wrong: "x" }}>Error!</Link>
 * ```
 * 
 * @since 1.0.0
 */
export type TypeSafeLinkProps<Path extends string> = 
  HasKeys<ExtractRouteParams<Path>> extends true
    ? {
        readonly to: Path
        readonly params: Simplify<ExtractRouteParams<Path>>
        readonly query?: Record<string, string>
        readonly replace?: boolean
        readonly children?: unknown
        readonly className?: string
      }
    : {
        readonly to: Path
        readonly params?: never
        readonly query?: Record<string, string>
        readonly replace?: boolean
        readonly children?: unknown
        readonly className?: string
      }

/**
 * Build a URL path by substituting params into a pattern.
 * 
 * @example
 * ```ts
 * buildPathWithParams("/users/:id", { id: "123" })
 * // "/users/123"
 * 
 * buildPathWithParams("/posts/:postId/comments/:commentId", { postId: "1", commentId: "2" })
 * // "/posts/1/comments/2"
 * ```
 * 
 * @since 1.0.0
 */
export const buildPathWithParams = <Path extends string>(
  path: Path,
  params: ExtractRouteParams<Path>
): string => {
  let result = path as string
  for (const [key, value] of Object.entries(params as Record<string, string>)) {
    result = result.replace(`:${key}`, value)
  }
  return result
}

// ==========================================
// Basic Types
// ==========================================

/**
 * Route parameters extracted from path
 * @since 1.0.0
 */
export type RouteParams = Record<string, string>

/**
 * Current route state
 * @since 1.0.0
 */
export interface Route {
  /** Current path (e.g., "/users/123") */
  readonly path: string
  /** Extracted route parameters */
  readonly params: RouteParams
  /** Query string parameters */
  readonly query: URLSearchParams
}

/**
 * Navigation options
 * @since 1.0.0
 */
export interface NavigateOptions {
  /** Replace current history entry instead of pushing */
  readonly replace?: boolean
  /** Query parameters to set */
  readonly query?: Record<string, string>
}

/**
 * Route definition - maps path pattern to component loader
 * @since 1.0.0
 */
export interface RouteDefinition {
  /** Path pattern (e.g., "/users/:id") */
  readonly path: string
  /** Component loader - returns Effect<Element> */
  readonly component: () => Promise<{ default: Effect.Effect<Element, unknown, never> }>
  /** Optional guard effect */
  readonly guard?: () => Promise<{ guard?: Effect.Effect<void, unknown, never> }>
  /** Optional loading component - displayed while route is loading */
  readonly loadingComponent?: () => Promise<{ default: Effect.Effect<Element, unknown, never> }>
  /** Optional error component - displayed when route errors, receives error via RouteError service */
  readonly errorComponent?: () => Promise<{ default: Effect.Effect<Element, unknown, never> }>
  /** Child routes (for nested layouts) */
  readonly children?: ReadonlyArray<RouteDefinition>
  /** Layout component for children */
  readonly layout?: () => Promise<{ default: Effect.Effect<Element, unknown, never> }>
}

/**
 * Route match result
 * @since 1.0.0
 */
export interface RouteMatch {
  /** The matched route definition */
  readonly route: RouteDefinition
  /** Extracted parameters */
  readonly params: RouteParams
  /** Parent matches (for nested routes) */
  readonly parents: ReadonlyArray<RouteMatch>
}

/**
 * Router redirect result - returned from guards to redirect
 * @since 1.0.0
 */
export interface RouterRedirect {
  readonly _tag: "RouterRedirect"
  readonly path: string
  readonly options?: NavigateOptions
}

/**
 * Create a redirect result for use in guards.
 * 
 * Use this in guard effects to redirect to another route.
 * The guard should yield* this effect to trigger the redirect.
 * 
 * @example
 * ```tsx
 * // routes/dashboard/index.tsx
 * import { Effect, Option } from "effect"
 * import { Router } from "effect-ui/router"
 * 
 * export const guard = Effect.gen(function* () {
 *   const user = yield* AuthService.getCurrentUser
 *   if (Option.isNone(user)) {
 *     yield* Router.redirect("/login")
 *   }
 * })
 * 
 * export default Effect.gen(function* () {
 *   return <div>Protected Dashboard</div>
 * })
 * ```
 * 
 * @since 1.0.0
 */
export const redirect = (path: string, options?: NavigateOptions): RouterRedirect => {
  const result: RouterRedirect = { _tag: "RouterRedirect", path }
  if (options !== undefined) {
    return { ...result, options }
  }
  return result
}

/**
 * Check if a value is a RouterRedirect
 * @since 1.0.0
 */
export const isRedirect = (value: unknown): value is RouterRedirect =>
  typeof value === "object" &&
  value !== null &&
  "_tag" in value &&
  (value as { _tag: unknown })._tag === "RouterRedirect"

/**
 * Guard blocked error - thrown when a guard blocks navigation
 * @since 1.0.0
 */
export class GuardBlocked {
  readonly _tag = "GuardBlocked"
  constructor(readonly redirect: RouterRedirect) {}
}

/**
 * Routes manifest - generated by vite plugin
 * @since 1.0.0
 */
export type RoutesManifest = ReadonlyArray<RouteDefinition>

/**
 * Route error info - available to _error.tsx components via RouteError FiberRef
 * @since 1.0.0
 */
export interface RouteErrorInfo {
  /** The error that occurred */
  readonly error: unknown
  /** The route path that errored */
  readonly path: string
  /** Reset effect to retry rendering the route - use in onClick handler */
  readonly reset: Effect.Effect<void, never, never>
}

/**
 * Router service interface
 * @since 1.0.0
 */
export interface RouterService {
  /** Signal containing current route state */
  readonly current: Signal<Route>
  
  /** Navigate to a path */
  readonly navigate: (path: string, options?: NavigateOptions) => Effect.Effect<void>
  
  /** Go back in history */
  readonly back: () => Effect.Effect<void>
  
  /** Go forward in history */
  readonly forward: () => Effect.Effect<void>
  
  /** Get current route params (type-safe) */
  readonly params: <P extends RouteParams>() => Effect.Effect<P>
  
  /** Get query params signal */
  readonly query: Signal<URLSearchParams>
  
  /** Check if a path matches current route */
  readonly isActive: (path: string, exact?: boolean) => Effect.Effect<boolean>
}
