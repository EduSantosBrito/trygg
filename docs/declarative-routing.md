# Declarative Routing

Effect-native declarative routing with Schema-validated params, middleware composition, and Layer-based loading strategies.

## Overview

Replaces file-based routing with explicit route definitions in a single `app/routes.ts` file. Routes are composed using a builder pattern with Effect-native patterns throughout.

### Core Principles

1. **Explicit route definitions** - All routes in `app/routes.ts`
2. **Schema-validated params** - Params decoded at match time using Effect Schema
3. **Middleware composition** - Chained execution with error propagation
4. **Layer-based loading** - Lazy/eager loading via `Effect.provide`
5. **Type-safe navigation** - Global `EffectUIRouteMap` generated by vite plugin
6. **No circular dependencies** - Path strings for navigation, types from `.effect-ui/`

---

## Route API

### Basic Route

```tsx
import { Route, Routes, Router } from "effect-ui/router"
import { Schema, Effect } from "effect"

Route.make("/users/:id")
  .params(Schema.Struct({ id: Schema.NumberFromString }))
  .component(UserProfile)
  .middleware(requireAuth)
  .middleware(logAccess)
  .loading(UserSkeleton)
  .error(UserError)
  .pipe(Effect.provide(Router.LazyLoading))
```

### Route Builder Methods

| Method | Description |
|--------|-------------|
| `.make(path)` | Create route with path pattern (`:param`, `:param*`, `:param+`) |
| `.params(schema)` | Schema for path params - keys must match path (type-safe) |
| `.query(schema)` | Schema for query params (decoded at match time) |
| `.component(Component)` | Component to render (Component.gen or Effect<Element>) |
| `.middleware(effect)` | Add middleware (chained, left-to-right execution) |
| `.prefetch(effect)` | Prefetch Resource on navigation (chained, parallel execution) |
| `.loading(Component)` | Loading fallback while route loads |
| `.error(Component)` | Error boundary for this route (nearest wins) |
| `.notFound(Component)` | 404 fallback for unmatched children (nearest wins) |
| `.forbidden(Component)` | 403 fallback for unauthorized access (nearest wins) |
| `.layout(Component)` | Layout wrapper (renders `<Router.Outlet />` for children) |
| `.children(...)` | Nested routes with relative paths |
| `.scrollRestoration(bool)` | Enable/disable scroll restoration (default: true) |
| `.pipe(...)` | Effect composition (e.g., loading strategy) |

### Routes Collection

```tsx
export const routes = Routes.make()
  .add(HomeRoute)
  .add(UsersRoute)
  .add(UserRoute)
  .add(SettingsRoutes)
  .notFound(NotFoundComponent)   // Root 404 handler
  .forbidden(ForbiddenComponent) // Root 403 handler
```

---

## Path Params with Schema

Path params are validated and decoded at **match time** using Effect Schema.

### Type-Safe Params

Schema keys must **exactly match** the path params - enforced at compile time:

```tsx
// GOOD - Schema matches path params
Route.make("/users/:id")
  .params(Schema.Struct({ id: Schema.NumberFromString }))

// ERROR - Schema missing 'id' from path
Route.make("/users/:id")
  .params(Schema.Struct({}))  // TS Error

// ERROR - Schema has extra key not in path
Route.make("/users/:id")
  .params(Schema.Struct({ 
    id: Schema.NumberFromString,
    name: Schema.String  // TS Error: 'name' not in path
  }))

// GOOD - no .params() needed when path has no params
Route.make("/about")
  .component(AboutPage)
```

### Type Extraction from Path

```tsx
// TypeScript extracts param names from path pattern
type ExtractParams<"/users/:id"> = "id"
type ExtractParams<"/users/:id/posts/:postId"> = "id" | "postId"
type ExtractParams<"/docs/:path*"> = "path"
type ExtractParams<"/about"> = never
```

### Dynamic Segments

```tsx
// Single param
Route.make("/users/:id")
  .params(Schema.Struct({ id: Schema.NumberFromString }))

// Multiple params
Route.make("/blog/:year/:month/:slug")
  .params(Schema.Struct({ 
    year: Schema.NumberFromString,
    month: Schema.NumberFromString,
    slug: Schema.String 
  }))
```

### Catch-All Routes

```tsx
// :param* = zero or more segments (optional)
Route.make("/docs/:path*")
  .params(Schema.Struct({ path: Schema.String }))
  .component(DocsPage)

// /docs           → path = ""
// /docs/intro     → path = "intro"
// /docs/api/users → path = "api/users"

// :param+ = one or more segments (required)
Route.make("/files/:filepath+")
  .params(Schema.Struct({ filepath: Schema.String }))
  .component(FileExplorer)

// /files/a/b/c    → filepath = "a/b/c"
// /files          → 404 (requires at least one segment)
```

### Usage in Component

```tsx
const UserProfile = Component.gen(function* () {
  const { id } = yield* Router.params("/users/:id")
  // id: number (decoded from Schema.NumberFromString)
  
  return <div>User {id}</div>
})
```

---

## Query Params with Schema

Query params are separate from path params and validated with `.query()`.

### Definition

```tsx
Route.make("/search")
  .query(Schema.Struct({ 
    q: Schema.String,
    page: Schema.optional(Schema.NumberFromString),
    sort: Schema.optional(Schema.Literal("asc", "desc"))
  }))
  .component(SearchPage)
```

### Combined Path and Query Params

```tsx
Route.make("/users/:id/posts")
  .params(Schema.Struct({ id: Schema.NumberFromString }))
  .query(Schema.Struct({ 
    filter: Schema.optional(Schema.Literal("published", "draft")),
    page: Schema.optional(Schema.NumberFromString)
  }))
  .component(UserPosts)
```

### Usage in Component

```tsx
const SearchPage = Component.gen(function* () {
  const { q, page, sort } = yield* Router.query("/search")
  // q: string
  // page: number | undefined
  // sort: "asc" | "desc" | undefined
  
  return <div>Search results for: {q}</div>
})

const UserPosts = Component.gen(function* () {
  const { id } = yield* Router.params("/users/:id/posts")
  const { filter, page } = yield* Router.query("/users/:id/posts")
  
  return <div>Posts by user {id}</div>
})
```

### Type Extraction

Vite plugin extracts types using Effect's native Schema inference:

```tsx
// Schema.NumberFromString -> number
// Schema.String -> string  
// Schema.Literal("a", "b") -> "a" | "b"
// Schema.optional(S) -> T | undefined
```

---

## Middleware

Middleware runs before component rendering. Chained execution with left-to-right ordering.

### Definition

```tsx
const requireAuth = Effect.gen(function* () {
  const session = yield* FiberRef.get(CurrentSession)
  if (Option.isNone(session)) {
    return Router.redirect("/login")  // Not authenticated → redirect
  }
  // Return void to continue
})

const requireAdmin = Effect.gen(function* () {
  const user = yield* FiberRef.get(CurrentUser)
  if (!user.isAdmin) {
    return Router.forbidden()  // Authenticated but not authorized → 403
  }
})

const logAccess = Effect.gen(function* () {
  yield* Effect.log("Route accessed")
})
```

### Chaining

```tsx
Route.make("/admin")
  .middleware(requireAuth)  // 1st: check auth → redirect if not logged in
  .middleware(requireAdmin) // 2nd: check admin role → 403 if not admin
  .middleware(logAccess)    // 3rd: log access
  .component(AdminDashboard)
  .forbidden(AdminForbidden)
```

### Middleware Signature

```tsx
type Middleware = Effect.Effect<
  void | RouterRedirect | RouterForbidden,  // void = continue
  unknown,                                   // Errors bubble to error boundary
  never                                      // R = never (services via FiberRef)
>
```

### Middleware Results

| Return | Behavior |
|--------|----------|
| `void` (no return) | Continue to next middleware or component |
| `Router.redirect(path)` | Redirect to another route |
| `Router.forbidden()` | Render nearest `.forbidden()` component |

### Error Handling

Middleware errors bubble to the nearest error boundary:

```tsx
Route.make("/dashboard")
  .middleware(requireAuth)  // Can fail with AuthenticationRequired
  .component(Dashboard)
  .error(DashboardError)    // Catches middleware errors
```

---

## Loading Strategy

Loading strategy is controlled via Effect Layers, defaulting to lazy loading.

### Layer-Based Loading

```tsx
// Implicit lazy loading (default)
Route.make("/users")
  .component(UsersList)

// Explicit lazy loading
Route.make("/users")
  .component(UsersList)
  .pipe(Effect.provide(Router.LazyLoading))

// Eager loading for critical paths
Route.make("/")
  .component(HomePage)
  .pipe(Effect.provide(Router.EagerLoading))
```

### Custom Loading Strategies

Create custom layers for advanced loading behavior:

```tsx
// Custom: prefetch on browser idle
const IdlePrefetchLoading = Layer.succeed(LoadingStrategy, {
  _tag: "LoadingStrategy",
  load: (loader) => Effect.gen(function* () {
    yield* Effect.promise(() => new Promise(r => requestIdleCallback(r)))
    return yield* Effect.promise(loader).pipe(Effect.map(m => m.default))
  })
})

Route.make("/reports")
  .component(Reports)
  .pipe(Effect.provide(IdlePrefetchLoading))
```

### LoadingStrategy Service

```tsx
interface LoadingStrategy {
  readonly _tag: "LoadingStrategy"
  readonly load: <A>(
    loader: () => Promise<{ default: A }>
  ) => Effect.Effect<A, LoadError, never>
}

// Provided layers
Router.LazyLoading   // Dynamic import at render time
Router.EagerLoading  // Component already imported
```

---

## Data Prefetching

Prefetch Resources when navigating to a route. Multiple `.prefetch()` calls run **in parallel**.

### Definition

```tsx
Route.make("/users/:id")
  .params(Schema.Struct({ id: Schema.NumberFromString }))
  .prefetch(({ params }) => 
    Effect.gen(function* () {
      return userResource({ id: params.id })
    })
  )
  .prefetch(({ params }) => 
    Effect.gen(function* () {
      return userPostsResource({ userId: params.id })
    })
  )
  .component(UserProfile)
```

### Behavior

1. Route matches (or Link hover with `prefetch="intent"`)
2. All `.prefetch()` Effects run **in parallel** via `Effect.all`
3. Each Effect returns a Resource
4. Resources are triggered to prefetch (populate cache)
5. Component renders, `Resource.fetch()` hits cache

### Constraints

- Prefetch Effect must be `Effect<Resource, E, never>` (R = never)
- Resource must have no requirements
- Errors in prefetch are logged but don't block navigation

### With Validation

```tsx
Route.make("/users/:id")
  .params(Schema.Struct({ id: Schema.NumberFromString }))
  .prefetch(({ params }) => 
    Effect.gen(function* () {
      // Can validate or do async setup
      if (params.id <= 0) {
        return yield* Effect.fail(new InvalidIdError())
      }
      return userResource({ id: params.id })
    })
  )
  .component(UserProfile)
```

### Simple Case

```tsx
// For simple cases, Effect.succeed wraps the resource
Route.make("/users/:id")
  .params(Schema.Struct({ id: Schema.NumberFromString }))
  .prefetch(({ params }) => Effect.succeed(userResource({ id: params.id })))
  .prefetch(({ params }) => Effect.succeed(userPostsResource({ userId: params.id })))
  .component(UserProfile)
```

### Usage in Component

```tsx
const UserProfile = Component.gen(function* () {
  const { id } = yield* Router.params("/users/:id")
  
  // These will likely hit cache if prefetched
  const userState = yield* Resource.fetch(userResource({ id }))
  const postsState = yield* Resource.fetch(userPostsResource({ userId: id }))
  
  return yield* Resource.match(userState, {
    Pending: () => <Skeleton />,
    Success: (user) => <div>{user.name}</div>,
    Failure: (err) => <Error error={err} />
  })
})
```

---

## Scroll Restoration

Automatic scroll-to-top on navigation. Configurable per-route.

### Default Behavior

- **New navigation**: Scroll to top
- **Back/Forward**: Restore previous scroll position
- **Hash links**: Scroll to element with matching id

### Opt-Out Per Route

```tsx
// Tabs or modals - don't scroll on child navigation
Route.make("/settings")
  .layout(SettingsLayout)
  .scrollRestoration(false)
  .children(
    Route.make("/profile").component(SettingsProfile),
    Route.make("/security").component(SettingsSecurity),
  )
```

### Global Configuration

```tsx
Routes.make()
  .add(HomeRoute)
  .add(SettingsRoutes)
  .scrollRestoration("auto")  // "auto" | "manual"
```

---

## Layouts

Layouts wrap child routes and render `<Router.Outlet />` for nested content.

### Definition

```tsx
Route.make("/settings")
  .layout(SettingsLayout)
  .middleware(requireAuth)
  .children(
    Route.make("/").component(SettingsIndex),
    Route.make("/profile").component(SettingsProfile),
    Route.make("/security").component(SettingsSecurity),
  )
```

### Layout Component

```tsx
const SettingsLayout = Component.gen(function* () {
  return (
    <div className="settings-layout">
      <aside className="settings-sidebar">
        <h2>Settings</h2>
        <nav>
          <Router.Link to="/settings">Overview</Router.Link>
          <Router.Link to="/settings/profile">Profile</Router.Link>
          <Router.Link to="/settings/security">Security</Router.Link>
        </nav>
      </aside>
      <div className="settings-content">
        <Router.Outlet />  {/* Child routes render here */}
      </div>
    </div>
  )
})
```

### Nested Layouts

Layouts stack from root to leaf:

```tsx
Route.make("/admin")
  .layout(AdminLayout)
  .children(
    Route.make("/users")
      .layout(AdminUsersLayout)
      .children(
        Route.make("/:id").component(AdminUserDetail),
      )
  )

// For /admin/users/123:
// <AdminLayout>
//   <AdminUsersLayout>
//     <AdminUserDetail />
//   </AdminUsersLayout>
// </AdminLayout>
```

---

## Children Routes

Children use **relative paths** that are resolved against the parent path.

### Definition

```tsx
Route.make("/settings")
  .layout(SettingsLayout)
  .children(
    Route.make("/").component(SettingsIndex),           // /settings
    Route.make("/profile").component(SettingsProfile),  // /settings/profile
    Route.make("/billing")
      .children(
        Route.make("/").component(BillingIndex),        // /settings/billing
        Route.make("/invoices").component(Invoices),    // /settings/billing/invoices
      )
  )
```

### Child Inheritance

Children inherit from parent:
- **Middleware**: Parent middleware runs before child middleware
- **Error boundary**: Nearest wins (child overrides parent if defined)
- **Not found**: Nearest wins (child overrides parent if defined)
- **Forbidden**: Nearest wins (child overrides parent if defined)
- **Loading component**: Nearest wins

---

## Not Found Handling

Not found components display when a path doesn't match any child route. **Nearest wins**.

### Definition

```tsx
Route.make("/admin")
  .layout(AdminLayout)
  .notFound(AdminNotFound)  // Handles /admin/unknown
  .children(
    Route.make("/users")
      .notFound(UsersNotFound)  // Handles /admin/users/unknown
      .children(
        Route.make("/:id").component(UserDetail),
      ),
    Route.make("/settings").component(AdminSettings),
  )
```

### Resolution

1. Path `/admin/users/unknown` doesn't match any route
2. Check if `/admin/users` has `.notFound()` → yes, render `UsersNotFound`
3. Path `/admin/reports` doesn't match
4. Check if `/admin` has `.notFound()` → yes, render `AdminNotFound`
5. Path `/unknown` doesn't match
6. Check if root `Routes` has `.notFound()` → render root not found

### Not Found Component

```tsx
const AdminNotFound = Component.gen(function* () {
  const router = yield* Router.getRouter
  const route = yield* Signal.get(router.current)
  
  return (
    <div className="not-found">
      <h1>Page Not Found</h1>
      <p>No admin page at: {route.path}</p>
      <Router.Link to="/admin">Back to Admin</Router.Link>
    </div>
  )
})
```

---

## Forbidden Handling

Forbidden components display when middleware returns `Router.forbidden()`. **Nearest wins**.

### Definition

```tsx
Route.make("/admin")
  .layout(AdminLayout)
  .middleware(requireAdmin)
  .forbidden(AdminForbidden)  // Handles 403 for /admin/*
  .children(
    Route.make("/billing")
      .middleware(requireBillingAccess)
      .forbidden(BillingForbidden)  // Handles 403 for /admin/billing/*
      .children(
        Route.make("/").component(BillingDashboard),
      ),
    Route.make("/users").component(AdminUsers),
  )
```

### Resolution

1. Middleware returns `Router.forbidden()`
2. Check if current route has `.forbidden()` → render it
3. If not, walk up to parent routes
4. First `.forbidden()` found handles it
5. If none found, render default "Access Denied" message

### Forbidden Component

```tsx
const AdminForbidden = Component.gen(function* () {
  const router = yield* Router.getRouter
  const route = yield* Signal.get(router.current)
  
  return (
    <div className="forbidden">
      <h1>Access Denied</h1>
      <p>You don't have permission to access: {route.path}</p>
      <Router.Link to="/">Go Home</Router.Link>
    </div>
  )
})
```

### Forbidden vs Redirect vs Error

| Scenario | Middleware Returns | Result |
|----------|-------------------|--------|
| Not logged in | `Router.redirect("/login")` | Navigate to /login |
| Logged in, no permission | `Router.forbidden()` | Render `.forbidden()` |
| Unexpected error | `Effect.fail(error)` | Render `.error()` |

---

## Error Boundaries

Error boundaries catch errors from middleware and components. **Nearest wins**.

### Definition

```tsx
Route.make("/dashboard")
  .middleware(requireAuth)
  .component(Dashboard)
  .error(DashboardError)
```

### Error Component

```tsx
const DashboardError = Component.gen(function* () {
  const { cause, path, reset } = yield* Router.currentError
  
  return (
    <div className="error">
      <h1>Error on {path}</h1>
      <pre>{String(Cause.squash(cause))}</pre>
      <button onClick={reset}>Try Again</button>
    </div>
  )
})
```

### Error Resolution

1. Route component/middleware fails
2. Check if route has `.error()` defined
3. If not, walk up to parent routes
4. First `.error()` found handles the error
5. If none found, error propagates to app-level boundary

---

## Navigation

### Router.Link

Type-safe link component with prefetch support:

```tsx
// Basic link
<Router.Link to="/users">Users</Router.Link>

// Link with params (type-checked against RouteMap)
<Router.Link to="/users/:id" params={{ id: 123 }}>View User</Router.Link>

// Link with query params
<Router.Link to="/search" query={{ q: "effect", page: 1 }}>Search</Router.Link>

// Prefetch behavior
<Router.Link to="/users" prefetch="intent">Users</Router.Link>  // Prefetch on hover
<Router.Link to="/users" prefetch="render">Users</Router.Link>  // Prefetch immediately
<Router.Link to="/users" prefetch={false}>Users</Router.Link>   // No prefetch
```

### Programmatic Navigation

```tsx
const SomeComponent = Component.gen(function* () {
  const router = yield* Router.get
  
  // Navigate to path
  yield* router.navigate("/users")
  
  // Navigate with params
  yield* router.navigate("/users/:id", { params: { id: 123 } })
  
  // Navigate with query
  yield* router.navigate("/search", { query: { q: "effect" } })
  
  // Replace history (no back)
  yield* router.navigate("/login", { replace: true })
  
  // Back/forward
  yield* router.back()
  yield* router.forward()
})
```

### Active Link Detection

```tsx
const NavLink = Component.gen(function* () {
  const isActive = yield* Router.isActive("/users")
  
  return (
    <Router.Link 
      to="/users" 
      className={isActive ? "active" : ""}
    >
      Users
    </Router.Link>
  )
})

// With params
const isUserActive = yield* Router.isActive("/users/:id", { params: { id: 123 } })
```

---

## Type Generation

Vite plugin generates `EffectUIRouteMap` in `.effect-ui/routes.d.ts`.

### Generated Types

```tsx
// .effect-ui/routes.d.ts
declare global {
  interface EffectUIRouteMap {
    "/": {}
    "/users": {}
    "/users/:id": { readonly id: number }
    "/settings": {}
    "/settings/profile": {}
    "/settings/security": {}
  }
}

export {}
```

### Type-Safe Navigation

Components use path strings - type safety comes from global `EffectUIRouteMap`:

```tsx
// No route imports needed - types from EffectUIRouteMap
const UserProfile = Component.gen(function* () {
  const { id } = yield* Router.params("/users/:id")  // id: number
  
  return (
    <div>
      {/* Type-safe: "/users/:id" requires params.id */}
      <Router.Link to="/users/:id" params={{ id: 456 }}>Other User</Router.Link>
      
      {/* Type-safe: "/users" has no params */}
      <Router.Link to="/users">Back to List</Router.Link>
    </div>
  )
})
```

### Avoiding Circular Dependencies

- Route definitions import components (one-way)
- Components navigate via path strings (no route imports)
- Types come from `.effect-ui/` (generated, not imported from router)

---

## Full Example

### Route Definitions

```tsx
// app/routes.ts
import { Route, Routes, Router } from "effect-ui/router"
import { Schema, Effect } from "effect"

// Components
import { HomePage } from "./pages/home"
import { Counter } from "./pages/counter"
import { UsersList } from "./pages/users"
import { UserProfile } from "./pages/users/profile"
import { SettingsLayout } from "./pages/settings/layout"
import { SettingsIndex } from "./pages/settings"
import { SettingsProfile } from "./pages/settings/profile"
import { SettingsSecurity } from "./pages/settings/security"
import { NotFound } from "./pages/404"
import { ErrorBoundary } from "./components/error"
import { LoadingSpinner } from "./components/loading"

// Middleware
import { requireAuth } from "./middleware/auth"

// Routes
export const routes = Routes.make()
  .add(
    Route.make("/")
      .component(HomePage)
      .pipe(Effect.provide(Router.EagerLoading))
  )
  .add(
    Route.make("/counter")
      .component(Counter)
  )
  .add(
    Route.make("/users")
      .component(UsersList)
  )
  .add(
    Route.make("/users/:id")
      .params(Schema.Struct({ id: Schema.String }))
      .component(UserProfile)
      .loading(LoadingSpinner)
      .error(ErrorBoundary)
  )
  .add(
    Route.make("/settings")
      .layout(SettingsLayout)
      .middleware(requireAuth)
      .forbidden(SettingsForbidden)
      .children(
        Route.make("/").component(SettingsIndex),
        Route.make("/profile").component(SettingsProfile),
        Route.make("/security")
          .middleware(requireSecurityAccess)
          .component(SettingsSecurity),
      )
      .error(ErrorBoundary)
      .notFound(SettingsNotFound)
  )
  .notFound(NotFound)
  .forbidden(Forbidden)
```

### App Entry

```tsx
// app/main.tsx
import { mount, Component } from "effect-ui"
import * as Router from "effect-ui/router"
import { routes } from "./routes"

const App = Component.gen(function* () {
  return (
    <div>
      <nav>
        <Router.Link to="/">Home</Router.Link>
        <Router.Link to="/counter">Counter</Router.Link>
        <Router.Link to="/users">Users</Router.Link>
        <Router.Link to="/settings">Settings</Router.Link>
      </nav>
      <main>
        <Router.Outlet routes={routes} />
      </main>
    </div>
  )
})

mount(document.getElementById("root")!, App)
```

### Page Component

```tsx
// app/pages/users/profile.tsx
import { Component } from "effect-ui"
import * as Router from "effect-ui/router"

export const UserProfile = Component.gen(function* () {
  const { id } = yield* Router.params("/users/:id")
  
  return (
    <div className="user-profile">
      <nav className="breadcrumb">
        <Router.Link to="/users">Users</Router.Link>
        <span> / {id}</span>
      </nav>
      <h1>User {id}</h1>
    </div>
  )
})
```

### Layout Component

```tsx
// app/pages/settings/layout.tsx
import { Component } from "effect-ui"
import * as Router from "effect-ui/router"

export const SettingsLayout = Component.gen(function* () {
  return (
    <div className="settings-layout">
      <aside className="settings-sidebar">
        <h2>Settings</h2>
        <nav>
          <Router.Link to="/settings">Overview</Router.Link>
          <Router.Link to="/settings/profile">Profile</Router.Link>
          <Router.Link to="/settings/security">Security</Router.Link>
        </nav>
      </aside>
      <div className="settings-content">
        <Router.Outlet />
      </div>
    </div>
  )
})
```

### Middleware

```tsx
// app/middleware/auth.ts
import { Effect, Option, FiberRef } from "effect"
import * as Router from "effect-ui/router"
import { CurrentSession, CurrentUser } from "../services/auth"

// Redirect if not authenticated
export const requireAuth = Effect.gen(function* () {
  const session = yield* FiberRef.get(CurrentSession)
  
  if (Option.isNone(session)) {
    return Router.redirect("/login")
  }
})

// Forbidden if authenticated but lacks permission
export const requireSecurityAccess = Effect.gen(function* () {
  const user = yield* FiberRef.get(CurrentUser)
  
  if (!user.permissions.includes("security:read")) {
    return Router.forbidden()
  }
})
```

---

## Migration from File-Based Routing

### Before (File-Based)

```
app/routes/
├── index.tsx           → /
├── counter.tsx         → /counter
├── users/
│   ├── index.tsx       → /users
│   └── [id].tsx        → /users/:id
└── settings/
    ├── _layout.tsx
    ├── index.tsx       → /settings
    ├── profile.tsx     → /settings/profile
    └── security.tsx    → /settings/security
```

### After (Declarative)

```
app/
├── routes.ts           # All route definitions
├── pages/
│   ├── home.tsx
│   ├── counter.tsx
│   ├── users/
│   │   ├── index.tsx
│   │   └── profile.tsx
│   └── settings/
│       ├── layout.tsx
│       ├── index.tsx
│       ├── profile.tsx
│       └── security.tsx
├── middleware/
│   └── auth.ts
└── components/
    ├── error.tsx
    └── loading.tsx
```

### Migration Steps

1. Create `app/routes.ts` with route definitions
2. Move components from `app/routes/*.tsx` to `app/pages/*.tsx`
3. Convert `_layout.tsx` to regular layout components
4. Convert `export const guard` to middleware effects
5. Remove file-based routing conventions (`[param]`, `_error`, `_loading`)
6. Update vite config to use declarative routing

---

## Vite Plugin Configuration

```tsx
// vite.config.ts
import { defineConfig } from "vite"
import effectUI from "effect-ui/vite-plugin"

export default defineConfig({
  plugins: [
    effectUI({
      routes: "./app/routes.ts"  // Path to route definitions
    })
  ]
})
```

### Plugin Behavior

1. Parse `app/routes.ts` at build time
2. Extract `Route.make()` calls and `.params()` schemas
3. Use Effect's type extraction for Schema types
4. Generate `.effect-ui/routes.d.ts` with `EffectUIRouteMap`
5. Watch for changes in development mode

---

## Comparison with TanStack Router

| Aspect | TanStack Router | Effect-UI |
|--------|----------------|-----------|
| Route definition | `createRoute()` | `Route.make()` |
| Component ref | Direct | Direct (`.component()`) |
| Route identity | Path + parent | Path only |
| Path params | `validateSearch` | Effect Schema (type-safe) |
| Query params | `validateSearch` | `.query(Schema)` |
| Catch-all | `$` suffix | `:param*` / `:param+` |
| Type extraction | Tree assembly | Vite plugin |
| Loading | `lazy()` wrapper | Effect Layers |
| Data loading | `loader` function | `.prefetch()` with Resource |
| Middleware | `beforeLoad` | `.middleware()` chain |
| Nesting | `getParentRoute()` | `.children()` inline |
| Error handling | Error component | `.error()` (nearest wins) |
| 404 handling | `notFoundComponent` | `.notFound()` (nearest wins) |
| 403 handling | Manual | `.forbidden()` (nearest wins) |
| Scroll | Built-in | Automatic + opt-out |
| Type safety | Tree inference | Global RouteMap |

---

## Implementation Phases

| Phase | Tasks |
|-------|-------|
| 1 | `Route` builder: `.make()`, `.component()`, `.layout()`, `.children()`, `.loading()` |
| 2 | Type-safe params: `.params(schema)` with compile-time path matching (`:param`, `:param*`, `:param+`) |
| 3 | Query params: `.query(schema)` with Schema validation |
| 4 | Boundary components: `.error()`, `.notFound()`, `.forbidden()` with nearest-wins resolution |
| 5 | `Routes` collection: `.add()`, `.notFound()`, `.forbidden()`, convert to `RoutesManifest` |
| 6 | Middleware: `.middleware()` chaining, `Router.redirect()`, `Router.forbidden()`, error propagation |
| 7 | Prefetch: `.prefetch(effect)` chaining, parallel execution, Resource cache integration |
| 8 | Loading layers: `Router.LazyLoading`, `Router.EagerLoading`, `LoadingStrategy` service |
| 9 | Scroll restoration: automatic scroll-to-top, `.scrollRestoration()` opt-out |
| 10 | Navigation: `Router.Link` with prefetch, `Router.isActive()`, programmatic navigation |
| 11 | Vite plugin: parse routes.ts, extract Schema types, generate `.effect-ui/routes.d.ts` |
| 12 | Outlet integration: consume new Route format, respect loading layers, boundary resolution |
| 13 | Migration: update @apps/examples, remove file-based routing support |
